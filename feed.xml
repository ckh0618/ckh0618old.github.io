<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>`whoami' </title>
    <description>일단 기술 블로그. 주관적. 구라가 섞일수 있으나 의도된 것은 아님.  
</description>
    <link>https://mo0om.com/</link>
    <atom:link href="https://mo0om.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 18 Aug 2019 18:24:07 +0900</pubDate>
    <lastBuildDate>Sun, 18 Aug 2019 18:24:07 +0900</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>PostgreSQL 에서 MemoryContext</title>
        <description>&lt;h2 id=&quot;배경&quot;&gt;배경&lt;/h2&gt;

&lt;p&gt;메모리 관리는 여러운 작업중에 하나입니다. 메모리를 할당하고 사용하는 것은 좋은데 할당받은 메모리 포인터를 적시에 반환하지 않거나 놓쳐버리는 경우 흔히 말하는 메모리 릭이 발생하게 됩니다. 이러한 문제는 간단한 커멘드라인 유틸리티등과 같이 짧은 시간 동작하고 종료되는 경우는 그리 큰 문제가 되지 않습니다. OS 가 알아서 프로세스가 종료될때 할당받은 자원을 정리하여 주거든요. 그러나 데이터베이스 서버와 같이 오랜시간 데몬 형태로 동작하여야하는 경우는 메모리를 다 잡아먹고 시스템을 서비스 불능 상태로 만들어버리는 등의 심각한 문제를 일으킬수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;memorycontext&quot;&gt;MemoryContext&lt;/h2&gt;

&lt;p&gt;PostgreSQL 에서는 이러한 메모리 관리 이슈를 단순화 하기 위하여 MemoryContext 라는 추상화된 개념을 사용합니다. MemoryContext 를 한마디로 간단히 표현하면 계층화된 Memory Pool Manager 라고 할 수 있는데요. 다음과 같은 동작을 지원합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Create&lt;/li&gt;
  &lt;li&gt;Allocate&lt;/li&gt;
  &lt;li&gt;Destroy&lt;/li&gt;
  &lt;li&gt;Reset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하나씩 살펴보면 다음과 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;create&quot;&gt;Create&lt;/h3&gt;

&lt;p&gt;새로운 MemoryContext 를 생성합니다. 이때 부모 Context 를 지정하는데, 최상위 부모는 TopMemoryContext 입니다. TopMemoryContext 하위에 각 모듈별로 세부적인 MemoryContext 가 존재합니다. 개발하는 모듈에 따라 만들고자 하는 MemoryContext 가 어느 위치에 존재하여야할지는 개발자가 판단하여야 합니다. 예를 들어 현재의 Transaction 으로 라이프사이클이 정해진  메모리를 할당하기 위해서는 CurTransactionContext 하단에 위치하는 MemoryContext 를 만들어서 사용하는 것이 유리합니다. 만약 내가 메모리 해제를 잊었더라도 CurTransactionContext 가 Destory 되면서 내가 할당한 MemoryContext 안의 메모리를 같이 정리해줄꺼니까요.&lt;/p&gt;

&lt;h3 id=&quot;allocate&quot;&gt;Allocate&lt;/h3&gt;

&lt;p&gt;현재 내가 사용하는 MemoryContext 를 통해서 메모리를 할당합니다. palloc() 을 하면 현재 내가 세팅한 MemoryContext 에서 관리되는 메모리를 리턴해줍니다. 이 내용은 아래에서 좀 더 자세히 살펴봅니다.&lt;/p&gt;

&lt;h3 id=&quot;destroy&quot;&gt;Destroy&lt;/h3&gt;

&lt;p&gt;현재 Context 를 삭제합니다. 계층화 되어서 좋은 이유가 여기서 나오는데, Destroy 는 현재 삭제되는 MemoryContext 하단의 MemoryContext 도 같이 같이 Destory 해줍니다. SQL옵션중에 CASCADE 와 비슷합니다. 그렇기 때문에 설령 하부 MemoryContext 에서 Destroy 하지 않더라도 상위에서 한번에 정리할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;reset&quot;&gt;Reset&lt;/h3&gt;

&lt;p&gt;현재 Memory Context 가 관리하는 메모리를 Reset 합니다 free() 와 동일한데, 해당 MemoryContext에서 할당된 메모리를 한번에 free() 한다고 생각하면 될것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;memorycontext-개념의-장점&quot;&gt;MemoryContext 개념의 장점&lt;/h2&gt;

&lt;p&gt;이러한 MemoryContext 라는 개념을 도입하면서 개발자는 다음과 같은 장점을 가집니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모듈 A 에서 관리되는 메모리는 모듈 A에서 만들어진 Context 에서 모두 관리됩니다. 만약 A 모듈의 하위 모듈인 A’ 모듈에서 새로운 Context 를 부모 Context 를 A 로 지정하여 만들어 관리 주체를 세분화 시킬수도 있습니다. 즉 이러한 세부적인 메모리 관리는 여러사람들이 코드를 고칠때 매우 높은 수준의 메모리 안정성을 제공할 수 있는 토대가 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기존의 전통적인 C 프로그램에서는 개발자가 메모리의 포인터를 다 관리하고 있어야 적절한 시점에 삭제하고 재사용할수 있도록 OS 에게 돌려줄수 있습니다. 그런데 이러한 MemoryContext 방식은 개발자가 단편화된 메모리를 관리할 필요가 없습니다. 필요할때마다 Allocation 을 통해 메모리를 할당받아서 사용하다가 해당 모듈이 종료되고 더 이상 해당 Memory Context 가 필요하지 않을때 한번에 삭제할수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Memory 관리를 Userspace에서 수행하는 것이기 때문에 훨씬 더 빠르고 OS 에 덜 의존적입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;memory-context--구현&quot;&gt;Memory Context  구현&lt;/h2&gt;

&lt;p&gt;PostgreSQL 은 현재 사용 중인 MemoryContext 를 저장하는 전역변수를 가지고 있습니다. palloc.h 를 보면 다음과 같은 정의를 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * CurrentMemoryContext is the default allocation context for palloc().
 * Avoid accessing it directly!  Instead, use MemoryContextSwitchTo()
 * to change the setting.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGDLLIMPORT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CurrentMemoryContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 전역변수를 통해서 현재 사용중인 MemoryContext 포인터를 일일이 전달하지 않고 malloc() / free() 와 동일하게 palloc() / pfree() 을 사용할 수 있습니다. palloc() 의 정의를 보면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;palloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* duplicates MemoryContextAlloc to avoid increased overhead */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MemoryContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CurrentMemoryContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;AssertArg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MemoryContextIsValid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;AssertNotInCriticalSection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;전역변수인 CurrentMemoryContext 에 세팅된 값을 얻어와서 설정하는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;memorycontext-사용&quot;&gt;MemoryContext 사용&lt;/h2&gt;

&lt;p&gt;CurrentMemoryContext 라는 전역변수가 있으니 직접 컨텍스트 할당하면 될것 같지만, 해당 변수의 선언에 달린 주석에서 경고한것 처럼 그렇게 하면 안됩니다. 대신 PostgreSQL 은 MemoryContextSwitchTo() 라는 함수를 정의했고 사용자는 이걸 사용하면 됩니다. 아래 코드와 같이 매우 간단합니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryContext&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;MemoryContextSwitchTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MemoryContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MemoryContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CurrentMemoryContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;CurrentMemoryContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MemoryContext 를 전환할때 old 값을 저장하라는 의미로 위 함수를 만들어놓은 것 같습니다.&lt;/p&gt;

&lt;p&gt;보통 MemoryContext 를 새롭게 생성하고 이를 사용하는 방식은 다음과 같이 정형화 되어있습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MemoryContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 

&lt;span class=&quot;c1&quot;&gt;// 새로운 MemoryContext 를 만듭니다. 부모는 TopMemoryContext 입니다. 
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AllocSetContextCreate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
						&lt;span class=&quot;n&quot;&gt;TopMemoryContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
						&lt;span class=&quot;s&quot;&gt;&quot;mytest context&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
&lt;span class=&quot;cp&quot;&gt;#if PG_VERSION_NUM &amp;gt;= 90600
&lt;/span&gt;						&lt;span class=&quot;n&quot;&gt;ALLOCSET_DEFAULT_SIZES&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;						&lt;span class=&quot;n&quot;&gt;ALLOCSET_DEFAULT_MINSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
						&lt;span class=&quot;n&quot;&gt;ALLOCSET_DEFAULT_INITSIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
						&lt;span class=&quot;n&quot;&gt;ALLOCSET_DEFAULT_MAXSIZE&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;						&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//  새로운 MemoryContext 로 전환. 이제부터 메모리 할당은 새로운 MemoryContext 에서 관리됩니다. 
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemoryContextSwitchTo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 

&lt;span class=&quot;cm&quot;&gt;/* do somthing.... */&lt;/span&gt; 

&lt;span class=&quot;c1&quot;&gt;// 다 썼으면 MemoryContext 를 이전값으로 옮겨줍니다. 
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MemoryContextSwitchTo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;MemoryContext 는 많은 사람들이 여러가지 모듈을 동시에 변경하는 PostgreSQL 에서 필수적으로 사용되는 개념입니다. 개발자는 자신의 모듈에 대해서만 메모리 관리를 신경쓰면 되고, 혹시라도 실수로 메모리 해제를 잊었더라도 상위 MemoryContext 가 삭제되면 같이 삭제되기 때문에 안전합니다.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.pgaddict.com/posts/introduction-to-memory-contexts&lt;/li&gt;
  &lt;li&gt;https://github.com/postgres/postgres/tree/master/src/backend/utils/mmgr&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 10 Jul 2019 00:00:00 +0900</pubDate>
        <link>https://mo0om.com/2019/07/10/what-is-memory-context-in-pg.html</link>
        <guid isPermaLink="true">https://mo0om.com/2019/07/10/what-is-memory-context-in-pg.html</guid>
        
        <category>PostgreSQL</category>
        
        <category>MemoryContext</category>
        
        <category>MemoryManager</category>
        
        <category>MemoryManagement</category>
        
        
        <category>PostgreSQL</category>
        
      </item>
    
      <item>
        <title>Github Pages에서 블로그를 시작합니다.</title>
        <description>&lt;h2 id=&quot;들아가며&quot;&gt;들아가며&lt;/h2&gt;

&lt;p&gt;github page 에 블로그를 만들어보았는데 상당히 간단합니다. Github Page 좋아보입니다. 뭐 Step By Step은 아니지만 걍 제가 어떻게 했는지 공유하면 나중에 페이지 만드는 사람도 좋을 것 같아서 공유 해봅니다.&lt;/p&gt;

&lt;h2 id=&quot;템플릿-찾기&quot;&gt;템플릿 찾기&lt;/h2&gt;

&lt;p&gt;요즘 도커에 빠져서 인터넷에 도커관련 자료를 찾으려 돌아다니는 도중에 &lt;a href=&quot;http://subicura.com&quot;&gt;subricura&lt;/a&gt;라는 분이 만든 블로그 템플릿을 보고 그대로 clone 받아서 꾸며봤습니다. 화면 레이아웃이나 기능들이 잘되어있어서요. 라이센스가 ISC 로 적혀있어서 그냥 가져다썼는데 허락 안받아도 되겠죠 ? 뭐 있는지도 모르시겠지만요.&lt;/p&gt;

&lt;p&gt;위 블로그 추천합니다. 특히 도커 관련 포스트는 매우 좋아요. 내공이 깊으신 거 같음.&lt;/p&gt;

&lt;p&gt;Clone 을 로컬에 아무데나 받고, 제가 수정한 내용은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일단 로컬에 클론을 하고,&lt;/li&gt;
  &lt;li&gt;파일을 열고 _post 디렉토리에 가서 기존의 post 들을 모두 지웠습니다 그리고 이글을 여기에 만들어서 넣었구요.&lt;/li&gt;
  &lt;li&gt;assets 에 보면 각 포스트에 종속된 이미지들이나 asciimena등의 자료들이 있는데 이것도 지우고&lt;/li&gt;
  &lt;li&gt;root 에 있는 config.yaml 을 여러서 제껄로 바꾸고, facebook app id도 새로 발급 받아서 댓글 시스템도 만들고요. 잘 모르는 것은 걍 주석 처리 했습니다.&lt;/li&gt;
  &lt;li&gt;그외에 대문 이미지와 뭐 기타 이미지들을 제껄로 변경했고,&lt;/li&gt;
  &lt;li&gt;물론 about.md 도 바꿔야죠. 현재는 쓸말이 없네요.&lt;/li&gt;
  &lt;li&gt;그외에는 잘 몰라서 걍 뒀습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jekyll&quot;&gt;jekyll&lt;/h2&gt;

&lt;p&gt;이거 컨셉이 좀 햇걸렸는데 걍 간단합니다. 사용자가 쓴 이런 저런 설정 및 템플릿과 마크다운 문서를 사용하여 Static 한 웹페이지 (HTML/Javascript/CSS) 로 만들어주는 겁니다. 기존의 워드프레스나 네이버블로그, 티스토리같은거랑은 좀 개념이 다르죠. 전자는 Site-generator라면 후자는 블로그 프로그램이니까요.&lt;/p&gt;

&lt;p&gt;Github Pages는 jekyll 을 기본 사이트 생성기로 사용하기 때문에 자동으로 jekyll 형식의 웹사이트를 Static하게 바꿔서 서비스 하기는 하는데, 그냥 jekyll을 도구로 사용하고 실제 Github Page 에는 Static 한 웹페이지를 올리는게 좋습니다. 이유는 다음 절에 나와요.&lt;/p&gt;

&lt;h2 id=&quot;배포하기&quot;&gt;배포하기&lt;/h2&gt;

&lt;p&gt;저대로 그냥 써도 되기는 합니다만, toc 등의 다른 jekyll plugin 등을 사용하기 위해서는 별도의 브랜치나 다른 Repository 에 코드를 가져다가 놓고, Page 의 master branch 로 완전한 Static HTML 형태로 배포하는 것이 좋습니다. package.json 의 저장소를 바꾸고 다음과 같이 사용하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm run deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;왜 이렇게 해야하냐면 Github Page 의 정책으로 인해서 Jekyll Plugin 중 몇개만 뺴고는 모두 막아버리기 때문입니다. 저렇게 하면 master 을 다 밀어버리고 그 안의 내용을 _site 디렉토리로 바꿔버립니다. 보이기는 똑같지만 jekyll 로 사이트 생성을 우리가 하는 거니까 Github Page 에서 지원하지 않는 Jekyll Plugin 을 마음대로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;저는 jekyll_toc 가 멋져보이더군요. 그래서 한 반나절 삽질했던거 같습니다.&lt;/p&gt;

&lt;p&gt;굳이 블로그용으로 저장소 두개 만드는 것이 좀 그래서 걍 code branch를 만들고 거기에는 블로그를 만들어내는 코드 ( 위에서 수정한 코드 베이스) 를 두고 master 는 배포용도로 세팅 했습니다.&lt;/p&gt;

&lt;h2 id=&quot;개인-도메인-연결&quot;&gt;개인 도메인 연결&lt;/h2&gt;

&lt;p&gt;예전에 사놨지만 까먹고 있었던 mo0om.com 이라는 도메인을 github page 내용을 보고 연결해놨습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/using-a-custom-domain-with-github-pages/&quot;&gt;Using a custom domain with github-pages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내용은 별게 없습니다. 도메인 네임서버를 설정하고, CNAME 파일을 page repository 에 넣으면 됩니다. 위에서 설정한건 아래 CloudFlare 설정에서 자동으로 읽어옵니다.&lt;/p&gt;

&lt;h2 id=&quot;ssl&quot;&gt;SSL&lt;/h2&gt;

&lt;p&gt;SSL 이 뭐 그리 필요할까 싶었지만 걍 뽀대나보이기 때문에 다음 내용을 보고 따라했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/cvan/8630f847f579f90e0c014dc5199c337b&quot;&gt;How to serve a custom https domain on github page with cloudflare&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CloudFare 서비스를 이용하여 쓰는 방식인데 쉬워요. domain의 dns 를 Cloud쪽으로 바꾸고 몇가지 설정을 하면 됩니다. 위 페이지에 잘 설명되어있습니다.&lt;br /&gt;
이제 끝난 거 같습니다. 글을 쓰고 publishing 합니다.&lt;/p&gt;

&lt;h2 id=&quot;google-analytics&quot;&gt;Google Analytics&lt;/h2&gt;

&lt;p&gt;역시 오바기는 하기만 Google Analytics 도 가입했습니다. 가입하고 나온 id 를 _config.yaml에 넣어주면 됩니다. 딱 보면 알껍니다. 이름이 워낙 직관적이라.&lt;/p&gt;

&lt;h2 id=&quot;이걸-시작하는-이유&quot;&gt;이걸 시작하는 이유&lt;/h2&gt;

&lt;p&gt;블로그야 뭐 서비스 형도 있고, 설치형도 있고 그런데 이게 좋아보이는 이유는,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Markdown 을 사용할 수 있는 것은 개인적으로 매우 큰 장점입니다.&lt;/li&gt;
  &lt;li&gt;귀찮기는 하지만 CSS 등을 직접 바꿔서 Customizing 을 할 수 있는 것도 좋고&lt;/li&gt;
  &lt;li&gt;이왕 Code Repository 로 github 을 쓰고 있으니 이걸 묶는게 좋아보이기도 하고&lt;/li&gt;
  &lt;li&gt;웬지 github 에 포스팅하면 있어보이는 개발자로 보이기도 하니까요.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;익숙하지는 않은 환경이라 완벽하게 돌아가는 코드 베이스가 있음에도 개념등을 찾아보느라 하루 반정도 삽질했네요. 뭘 적을 수 있을지는 모르겠지만 뭐 고민해보죠.&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Mar 2018 00:00:00 +0900</pubDate>
        <link>https://mo0om.com/2018/03/10/let-get-started-copy.html</link>
        <guid isPermaLink="true">https://mo0om.com/2018/03/10/let-get-started-copy.html</guid>
        
        <category>BLOG. SSL</category>
        
        <category>Github Pages</category>
        
        <category>jekyll</category>
        
        <category>CloudFlare</category>
        
        
        <category>Life</category>
        
      </item>
    
  </channel>
</rss>
