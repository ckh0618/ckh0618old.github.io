<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>A Blog from Han</title>
    <description>일단 기술 블로그. 주관적. 구라가 섞일수 있으나 의도된 것은 아님.   
</description>
    <link>https://mo0om.com/</link>
    <atom:link href="https://mo0om.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 24 Apr 2018 23:07:57 +0900</pubDate>
    <lastBuildDate>Tue, 24 Apr 2018 23:07:57 +0900</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>MySQL InnoDB 의 Default isolation level</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;들아가며&lt;/h2&gt;

&lt;p&gt;DBMS 에서 제공하는 수백개 이상의 설정 속성을 하나하나 다 알고 해당 값의 합리성을 의심하면서 쓰는 건 솔직히 불가능합니다. 그래서 꼭 바꿔야하는 널리 알려진 속성,  예를 들어 Language 관련 속성이나 Buffer Pool 의 크기와 같은 값을 제외하고는 뭐 쓸만하니까 해당 값을 생각했겠지라고 사용하는 것이 대부분일겁니다.  &lt;/p&gt;

&lt;p&gt;그런데 MySQL innodb 에는 이러한 믿음을 깨버리는 설정 값이 있습니다. 바로 tranaction-isolation 이라는 속성인데, 기본값이  REPEATABLE READ 입니다. 며칠동안 궁금해서 MySQL 에서 왜 해당 값을 기본값으로 삼았는지에 대해서 찾아봤습니다. 일단 ISOLATION LEVEL 부터 봅시다. &lt;/p&gt;

&lt;h2 id=&quot;isolation-level&quot;&gt;ISOLATION LEVEL&lt;/h2&gt;

&lt;p&gt;ISOLATION LEVEL 은 트렌젝션의 격리성을 의미합니다. ISOLATION는 격리성 또는 고립성이라는 한자어로 번역되는데, 간단히 말하면 서로 동시에 수행되는 트렌젝션들이 다른 트렌젝션이 일으킨 변화에 대한 영향을 어디까지 허용할 것인가로 보면 됩니다. 트렌젝션의 4가지 속성 기억나시죠 ? ACID 중 I에 해당 되는 놈입니다. &lt;/p&gt;

&lt;p&gt;이러한 ISOLATION LEVEL은 예로부터 ANSI 에서 다음과 같이 4가지로 정의했습니다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;READ UNCOMMITED &lt;/li&gt;
  &lt;li&gt;READ COMMITED &lt;/li&gt;
  &lt;li&gt;REPEATABLE READ &lt;/li&gt;
  &lt;li&gt;SERIALIZABLE&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;read-uncommited&quot;&gt;READ UNCOMMITED&lt;/h4&gt;

&lt;p&gt;용어 그대로 커밋되지 않은 레코드를 읽을 수 있다라는 것으로 이해하면 됩니다. 예를 들어서 다음과 같은 상황이 동시에 일어 났다고 합시다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;트렌젝션 A : T1 테이블의 r1 row 를 c1 컬럼을 1에서 2로 바꾸는 중입니다.  &lt;/li&gt;
  &lt;li&gt;트렌젝션 B : T1 테이블을 SELECT 합니다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 트렌젝션 B 에서 읽은 값이 만약 2라면 이를 READ UNCOMMITED ISOLATION LEVEL 이라고 합니다. 엄밀하게 말하면 트렌젝션 A는 아직 Commit 하지 않은 데이터이기 떄문에 트렌젝션 B는 1을 읽어야 합니다. 사실 이렇게 데이터를 읽는 경우는 버그라고 볼 수도 있습니다. &lt;/p&gt;

&lt;p&gt;그런데 이걸 ANSI 에서 ISOLATION LEVEL 의 한 단계로 설정한 까닭은 무엇일까요 ? 답은 간단합니다. 읽기연산에서 Locking 에 대한 고려가 필요없기 때문입니다. 읽기는 절대로 블럭되지 않습니다. 그리고 읽기가 별도의 LOCK 을 세팅하지 않기 때문에 읽는 것때문에 다른 것들이 블럭되지도 않습니다.  물론 값의 일관성이 깨지는 건 각오해야겠죠. 센서 데이터와 같이 값의 일관성이 크게 중요하지 않은 곳에서는 사용할 만 합니다. &lt;/p&gt;

&lt;p&gt;Oracle 은 Concept Guide를 잘 읽으신 분이나 OCP 를 공부하신 분들은 잘 아시겠지만 READ UNCOMMITED 라는 ISOLATION을 아예 지원도 하지 않습니다. 이는 Oracle 특유의 MVCC 방법 때문에 SELECT 는 그냥 SNAPSHOT 이기 때문입니다. 즉 굳이 Dirty Read 를 하지 않더라도 거기에 준하는 동시성을 보장한다 생각하면 될것 같습니다. MVCC 주제는 너무 크니까 나중에 다른 포스트로 다시 정리해보겠습니다. 재밌는 내용이 많습니다. &lt;/p&gt;

&lt;h4 id=&quot;read-commited&quot;&gt;READ COMMITED&lt;/h4&gt;

&lt;p&gt;말 그래도 커밋된 놈은 읽는다 라는 뜻입니다. 한 트렌젝션 안에서 데이터를 읽을떄 다른 트렌젝션이 이미 읽어서 COMMIT 을 수행했으면 그 값을 읽습니다. 우리가 밀반적으로 DBMS 라고 하면 대부분 기본이 바로 이겁니다. 그렇기 때문에 한 트렌젝션 안에서 동일한  SELECT 가 여러 번 반복 될때 매번 결과가 바뀔 수 있습니다. 여러번 읽을때 값이 바뀌는 것을 Non-Repeatable Read 라고 하고, 갑자기 처음읽을때와 두번째 읽을떄 새로운 row 가 튀어나오는 경우를 Phantom Read라고 하는데 READ COMMITED 에서는 둘다 발생합니다. &lt;/p&gt;

&lt;p&gt;흔히 주니어들이 많이 하는 실수죠. SELECT 로 읽어서 변수에다가 넣어놨는데 이걸 가지고 UPDATE 하러 갔더니 갑자기 Not Found 또는 엉뚱한 값으로 값이 바뀌어있더라.. 아니면 내가 분명히 보고 그 값을 업데이트했는데 업데이트가 사라졌더라. (이런 상황을 Lost Update 라고 합니다) 뭐 이런거요. 보통 이런 상황 발생하면 DBMS 버그라고 난리치기도 하죠. ( DBMS 가 명령을 가끔 씹는다고 표현하는 것도 들은 적이 있습니다 )&lt;/p&gt;

&lt;p&gt;그렇기 때문에 서로 동시에 Transaction 이 발생하는 시스템에서는 SELECT ~ FOR UPDATE 구문이 필요합니다. 만약 Row A 를 읽고 나서 이를 무언가 처리를 수행하고, 해당 컬럼의 값을 변경하는 업무 일경우 내가 읽은 값을 아무도 못건드리게 해야 안심하고 업데이트할 수 있습니다. &lt;/p&gt;

&lt;p&gt;주로 웬만한 DBMS 들이 기본으로 가지는 ISOLATION LEVEL입니다. &lt;/p&gt;

&lt;h4 id=&quot;repeatable-read&quot;&gt;REPEATABLE READ&lt;/h4&gt;

&lt;p&gt;이름 그대로 트렌젝션 어느시점에 값을 조회하더라도 동일한 값을 갖도록 하는 하는 방식입니다. Read Commited 에서는 한 트렉젝션여서 여러번 SELECT 를 수행하면 값이 바뀔 수 있다고 했는데, REPEATABLE READ 는 값이 동일합니다. &lt;/p&gt;

&lt;p&gt;그럼 의문을 가질 수 있는게 누군가 데이터를 바꾸면 어쩌지 입니다. 예를 들어서 트렌젝션 초반에 읽은 값이 누군가 변경했더라도 진행 중인 트렌젝션에서는 알아챌 수 없습니다. 그래서 내가 읽은 레코드가 누군가로 부터 바뀌지 않음을 보장하려면 무조건 SELECT ~ FOR UPDATE 를 써야합니다. &lt;/p&gt;

&lt;p&gt;REPETABLE READ 에서는  Phantom Read 를 막을 수 없고, Non-Repetable Read 는 막을 수 있습니다만 MySQL은 둘다 막습니다. &lt;/p&gt;

&lt;h4 id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/h4&gt;

&lt;p&gt;어떤 테이블에 SELECT 를 수행하면 해당 SELECT 가 수행된 영역에 INSERT / UPDATE / DELETE 가 불가능합니다. 근데 뭐 이 설정은 거의 볼일이 없습니다.  과감히 무시하고 넘어갑니다. &lt;/p&gt;

&lt;h2 id=&quot;mysql--transaction-isolation&quot;&gt;MySQL 에서 transaction-isolation&lt;/h2&gt;

&lt;p&gt;MySQL InnoDB 에서 제공하는 Repetable Read 는  엄밀한 Repeatable Read 와는 달라요. 위에서도 잠깐 언급했지만,  Repetable Read 와 Serializable 중간에 있습니다. 그래서 Phantom Read 를 허용하지 않는 Serialization 의 속성을 가집니다. 문제는 이러한 모호성때문에 Insert 가 Lock wait 하는 재밌지만 미쳐버리는 상황이 발생합니다. 특히 기존에 Oracle 에 익숙한 사람들은 뜬금없는 Lock 과 Deadlock 앙상블에 맨붕이 오기도 합니다. 뭐 예를 들어 다음과 같은 경우죠. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Table T1 을 FULL Scan 하는 쿼리를 수행하는 트렌젝션이 있다면, 이 트렌젝션이 끝나기 전까지 어떤 트렌젝션도 T1에 데이터를 INSERT 할 수 없습니다. &lt;/li&gt;
  &lt;li&gt;INSERT INTO T1 SELECT * FROM T1 구문은 그 자체가 블락됩니다.  &lt;/li&gt;
  &lt;li&gt;SELECT * FROM T1 WHERE C1 BETWEEN 1 AND 100 이라는 구문은 T1 테이블에 1 ~ 100 사이 어떤 값도 입력 , 수정될수 없도록 블럭합니다. GAP LOCK 이라고 합니다. &lt;/li&gt;
  &lt;li&gt;SELECT A.* FROM A LEFT OUTER JOIN B WHERE A.C1 = B.C1 WHERE A.C2 = 1 FOR UPDATE 이라는 쿼리가 있고 해당 쿼리의 결과가 No Rows 라도 해당 트렌젝션이 끝날때까지 B 테이블에 어떠한 값 입력도 할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;내가 한번 값을 읽으면 다른 트렌젝션이 그 값을 바꾸었다는 걸을 알수 없습니다. 그래서 SELECT - FOR UPDATE 는 Exclusive Lock 을 설정하고 해당 Row의 최신 값을 가지고 오는 것으로 의미가 확장됩니다. Shared Lock 을 거는 LOCK IN SHARE MODE 라는 구문도 있는데 역시 최신값을 가지고 와서 다른 Transaction 이 못 바꾸게 합니다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MySQL 쪽에서도 이걸 바꿔보려고 &lt;a href=&quot;http://www.tocker.ca/2015/01/14/proposal-to-change-replication-and-innodb-settings-in-mysql-5-7.html&quot;&gt;시도&lt;/a&gt;는 한거 같은데, 호환성의 이슈로 반려당한걸로 보입니다. 사실 메이저 버젼 변경도 아니고, MySQL 과 같이 많이 사용되는 DBMS 의 기본값은 변경하기 상당히 까다롭습니다. 게다가 이렇게 데이터의 정합성에 영향을 미치는 기본값은 매우 변경하기 힘들죠. &lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;영향도&lt;/h3&gt;

&lt;p&gt;사실 실제 운영되는 시스템에서 이 값 함부로 못바꿉니다. 특히 Concurrenct 한 Operation 이 자주 일어나는 시스템에서는 업무 고려를 일일히 해봐야합니다. 답이 달라 질 수 있고, 데이터가 의도하지 않은 상태로 바뀌어버릴 수 있습니다. &lt;/p&gt;

&lt;p&gt;그리고 Replication 을 사용할때 SBR ( Statement Based Replication)  을 사용하지 못합니다. RBR ( Row Based Replication) 만 사용할 수 있습니다. 당연합니다. 동시에 수행할 수 있는 트렌젝션의 Concurrency 가 늘었기 때문입니다. &lt;/p&gt;

&lt;p&gt;잘못 설정된 기본값이 이렇게 무섭습니다. &lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;마무리&lt;/h2&gt;

&lt;p&gt;장황했지만 두줄 요약입니다.  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최초 MySQL InnoDB 를 구성할때 transaction-isolation 값을 READ COMMITED 로 바꿔라. &lt;/li&gt;
  &lt;li&gt;그러나 기존 운영시스템의 기본값은 바꾸지 마라. 완벽하게 어플리케이션을 통제하고 있지 못한 상태에서 바꾸면 잡기도 어려운 동시성 문제가 발생한다. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이글의 메인 주제였던 왜 MySQL 은 Repeatable Read 가 기본일까 ? 라는 건 사실 답을 못찾았습니다. 그냥 개발자 취향인것으로 이해하고 있습니다. &lt;/p&gt;
</description>
        <pubDate>Sun, 01 Apr 2018 00:00:00 +0900</pubDate>
        <link>https://mo0om.com/2018/04/01/innodb_default_isolation.html</link>
        <guid isPermaLink="true">https://mo0om.com/2018/04/01/innodb_default_isolation.html</guid>
        
        <category>InnoDB. ACID</category>
        
        <category>MySQL</category>
        
        <category>transaction-isolation</category>
        
        
        <category>dbms</category>
        
      </item>
    
      <item>
        <title>Github Pages에서 블로그를 시작합니다.</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;들아가며&lt;/h2&gt;

&lt;p&gt;github page 에 블로그를 만들어보았는데 상당히 간단합니다. Github Page 좋아보입니다. 뭐 Step By Step은 아니지만 걍 제가 어떻게 했는지 공유하면 나중에 페이지 만드는 사람도 좋을 것 같아서 공유 해봅니다.  &lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;템플릿 찾기&lt;/h2&gt;

&lt;p&gt;요즘 도커에 빠져서 인터넷에 도커관련 자료를 찾으려 돌아다니는 도중에 &lt;a href=&quot;http://subicura.com&quot;&gt;subricura&lt;/a&gt;라는 분이 만든 블로그 템플릿을 보고 그대로 clone 받아서 꾸며봤습니다. 화면 레이아웃이나 기능들이 잘되어있어서요. 라이센스가 ISC 로 적혀있어서 그냥 가져다썼는데 허락 안받아도 되겠죠 ? 뭐 있는지도 모르시겠지만요. &lt;/p&gt;

&lt;p&gt;위 블로그 추천합니다. 특히 도커 관련 포스트는 매우 좋아요. 내공이 깊으신 거 같음. &lt;/p&gt;

&lt;p&gt;Clone 을 로컬에 아무데나 받고, 제가 수정한 내용은 다음과 같습니다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일단 로컬에 클론을 하고, &lt;/li&gt;
  &lt;li&gt;파일을 열고 _post 디렉토리에 가서 기존의 post 들을 모두 지웠습니다 그리고 이글을 여기에 만들어서 넣었구요.&lt;/li&gt;
  &lt;li&gt;assets 에 보면 각 포스트에 종속된 이미지들이나 asciimena등의 자료들이 있는데 이것도 지우고&lt;/li&gt;
  &lt;li&gt;root 에 있는 config.yaml 을 여러서 제껄로 바꾸고, facebook app id도 새로 발급 받아서 댓글 시스템도 만들고요. 잘 모르는 것은 걍 주석 처리 했습니다.  &lt;/li&gt;
  &lt;li&gt;그외에 대문 이미지와 뭐 기타 이미지들을 제껄로 변경했고, &lt;/li&gt;
  &lt;li&gt;물론 about.md 도 바꿔야죠. 현재는 쓸말이 없네요.  &lt;/li&gt;
  &lt;li&gt;그외에는 잘 몰라서 걍 뒀습니다. &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jekyll&quot;&gt;jekyll&lt;/h2&gt;

&lt;p&gt;이거 컨셉이 좀 햇걸렸는데 걍 간단합니다. 사용자가 쓴 이런 저런 설정 및 템플릿과 마크다운 문서를 사용하여 Static 한 웹페이지 (HTML/Javascript/CSS) 로 만들어주는 겁니다. 기존의 워드프레스나 네이버블로그, 티스토리같은거랑은 좀 개념이 다르죠. 전자는 Site-generator라면 후자는 블로그 프로그램이니까요.&lt;/p&gt;

&lt;p&gt;Github Pages는 jekyll 을 기본 사이트 생성기로 사용하기 때문에 자동으로 jekyll 형식의 웹사이트를 Static하게 바꿔서 서비스 하기는 하는데, 그냥 jekyll을 도구로 사용하고 실제 Github Page 에는 Static 한 웹페이지를 올리는게 좋습니다. 이유는 다음 절에 나와요. &lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;배포하기&lt;/h2&gt;

&lt;p&gt;저대로 그냥 써도 되기는 합니다만, toc 등의 다른 jekyll plugin 등을 사용하기 위해서는 별도의 브랜치나 다른 Repository 에 코드를 가져다가 놓고, Page 의 master branch 로 완전한 Static HTML 형태로 배포하는 것이 좋습니다. package.json 의 저장소를 바꾸고 다음과 같이 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ npm run deploy
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;왜 이렇게 해야하냐면 Github Page 의 정책으로 인해서 Jekyll Plugin 중 몇개만 뺴고는 모두 막아버리기 때문입니다. 저렇게 하면 master 을 다 밀어버리고 그 안의 내용을 _site 디렉토리로 바꿔버립니다. 보이기는 똑같지만 jekyll 로 사이트 생성을 우리가 하는 거니까 Github Page 에서 지원하지 않는 Jekyll Plugin 을 마음대로 사용할 수 있습니다.  &lt;/p&gt;

&lt;p&gt;저는 jekyll_toc 가 멋져보이더군요. 그래서 한 반나절 삽질했던거 같습니다. &lt;/p&gt;

&lt;p&gt;굳이 블로그용으로 저장소 두개 만드는 것이 좀 그래서 걍 code branch를 만들고 거기에는 블로그를 만들어내는 코드 ( 위에서 수정한 코드 베이스) 를 두고 master 는 배포용도로 세팅 했습니다. &lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;개인 도메인 연결&lt;/h2&gt;

&lt;p&gt;예전에 사놨지만 까먹고 있었던 mo0om.com 이라는 도메인을 github page 내용을 보고 연결해놨습니다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/using-a-custom-domain-with-github-pages/&quot;&gt;Using a custom domain with github-pages&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내용은 별게 없습니다. 도메인 네임서버를 설정하고, CNAME 파일을 page repository 에 넣으면 됩니다. 위에서 설정한건 아래 CloudFlare 설정에서 자동으로 읽어옵니다. &lt;/p&gt;

&lt;h2 id=&quot;ssl&quot;&gt;SSL&lt;/h2&gt;

&lt;p&gt;SSL 이 뭐 그리 필요할까 싶었지만 걍 뽀대나보이기 때문에 다음 내용을 보고 따라했습니다. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/cvan/8630f847f579f90e0c014dc5199c337b&quot;&gt;How to serve a custom https domain on github page with cloudflare&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CloudFare 서비스를 이용하여 쓰는 방식인데 쉬워요. domain의 dns 를 Cloud쪽으로 바꾸고 몇가지 설정을 하면 됩니다. 위 페이지에 잘 설명되어있습니다.&lt;br /&gt;
이제 끝난 거 같습니다. 글을 쓰고 publishing 합니다. &lt;/p&gt;

&lt;h2 id=&quot;google-analytics&quot;&gt;Google Analytics&lt;/h2&gt;

&lt;p&gt;역시 오바기는 하기만 Google Analytics 도 가입했습니다. 가입하고 나온 id 를 _config.yaml에 넣어주면 됩니다. 딱 보면 알껍니다. 이름이 워낙 직관적이라. &lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;이걸 시작하는 이유&lt;/h2&gt;

&lt;p&gt;블로그야 뭐 서비스 형도 있고, 설치형도 있고 그런데 이게 좋아보이는 이유는,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Markdown 을 사용할 수 있는 것은 개인적으로 매우 큰 장점입니다. &lt;/li&gt;
  &lt;li&gt;귀찮기는 하지만 CSS 등을 직접 바꿔서 Customizing 을 할 수 있는 것도 좋고 &lt;/li&gt;
  &lt;li&gt;이왕 Code Repository 로 github 을 쓰고 있으니 이걸 묶는게 좋아보이기도 하고 &lt;/li&gt;
  &lt;li&gt;웬지 github 에 포스팅하면 있어보이는 개발자로 보이기도 하니까요.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;익숙하지는 않은 환경이라 완벽하게 돌아가는 코드 베이스가 있음에도 개념등을 찾아보느라 하루 반정도 삽질했네요. 뭘 적을 수 있을지는 모르겠지만 뭐 고민해보죠. &lt;/p&gt;
</description>
        <pubDate>Sat, 10 Mar 2018 00:00:00 +0900</pubDate>
        <link>https://mo0om.com/2018/03/10/let-get-started.html</link>
        <guid isPermaLink="true">https://mo0om.com/2018/03/10/let-get-started.html</guid>
        
        <category>BLOG. SSL</category>
        
        <category>Github Pages</category>
        
        <category>jekyll</category>
        
        <category>CloudFlare</category>
        
        
        <category>life</category>
        
      </item>
    
  </channel>
</rss>
